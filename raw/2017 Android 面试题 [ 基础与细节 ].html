<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">   <meta charset="utf-8"/>
<style>img{max-width: 100%; width:auto; height:auto;}</style>
<style>
/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
overflow-x: scroll;
  overflow-y: hidden;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}</style>
  <title>MDReader</title>
</head>
<body>
  <div id="content"><h1 id="2017-android-面试题-基础与细节-">2017 Android 面试题 [ 基础与细节 ]</h1>
<blockquote>
<p>感谢<a href="https://segmentfault.com/a/1190000008682444">@chuyao</a>抛出的这些问题，平时业务代码写多了，很多基础的东西变得含糊不清了，这次裸辞出来找工作确实没有之前顺利，顺便求上海Android开发的坑。
我自己整理了些答案，不对或者不妥的地方请大家指出，谢谢。</p>
</blockquote>
<h3 id="1-activity建立在哪些窗口组件之上-顺带涉及view的事件传递问题-">1. Activity建立在哪些窗口组件之上？顺带涉及View的事件传递问题。</h3>
<p>没读懂问题，=。=不知道是不是问Activity的UI结构，如果是可以<a href="http://www.cnblogs.com/lcw/p/3372914.html">参考这篇文章</a>。
<img src="pic/Activity的window和view系统的层级关系.jpg" alt="这个？"></p>
<p>对于View的事件传递，则可以从 <code>Activity --&gt; ViewGroup --&gt; ...... --&gt; Activity</code> 的<strong> U型 </strong>消费结构去说。</p>
<h3 id="2-什么情况下-activity的onnewinstent-方法会执行-activity的启动模式相关-">2. 什么情况下，Activity的onNewInstent()方法会执行？Activity的启动模式相关。</h3>
<p>当此Activity的实例已经存在，并且此时的启动模式为<code>SingleTask</code>和<code>SingleInstance</code>，另外当这个实例位于栈顶且启动模式为<code>SingleTop</code>时也会触发<code>onNewInstent()</code>。</p>
<h3 id="3-activity-a使用startforresult启动activity-b-b什么都不做并返回a-a中的onactivityresult回调是否会执行-">3. Activity A使用startForResult启动Activity B，B什么都不做并返回A，A中的onActivityResult回调是否会执行？</h3>
<p>startActivity()方法，最终都是调用<code>startActivityForResult()</code>方法。默认的<code>requestCode = -1  resultCode = RESULT_CANCELED = 0</code>，当你的<code>requestCode ！= -1</code>时，<code>onActivityResult()</code>一定会被调用。</p>
<h3 id="4-fragment能否不依赖于activity存在-简析一下fragment的栈管理-">4. Fragment能否不依赖于Activity存在？简析一下Fragment的栈管理。</h3>
<p><strong>Fragment不能独立存在</strong>，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。</p>
<pre><code>
// Create new fragment and transaction
Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragmentManager().beginTransaction();

// Replace whatever is in the fragment_container view with this fragment,
// and add the transaction to the back stack
transaction.replace(R.id.fragment_container, newFragment);
transaction.addToBackStack(null);

// Commit the transaction
transaction.commit();
</code></pre>
<p>transaction只是记录了从一个状态到另一个状态的变化过程，即比如从FragmentA替换到FragmentB的过程，当通过函数transaction.addToBackStack(null)将这个事务添加到回退栈，则会记录这个事务的状态变化过程，如从FragmentA —&gt;FragmentB,当用户点击手机回退键时，因为transaction的状态变化过程被保存，则可以将事务的状态变化过程还原，即将FragmentB —&gt; FragmentA.</p>
<p>添加到回退栈的函数：transaction.addToBackStack(null);</p>
<p><a href="http://blog.csdn.net/u011026329/article/details/47903177">参考文章： http://blog.csdn.net/u011026329/article/details/47903177</a></p>
<h3 id="5-能否将一个activity放到系统的最近任务列表里-独立于宿主app任务卡之外-">5. 能否将一个Activity放到系统的最近任务列表里，独立于宿主app任务卡之外？</h3>
<pre><code>
我印象中是可以做到了，平时没用到，知道的同学请@我，谢谢！
</code></pre>
<h3 id="6-对于同一个service-在被start启动之后还能不能被bind-">6. 对于同一个Service，在被start启动之后还能不能被bind？</h3>
<p><strong>能</strong></p>
<blockquote>
<p>服务基本上分为两种形式：
<strong>启动</strong>
当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。
<strong>绑定</strong>
当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<p>虽然本文档是分开概括讨论这两种服务，<strong>但是您的服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。</strong>
<a href="https://developer.android.google.cn/guide/components/services.html">来自官方文档</a></p>
</blockquote>
<h3 id="7-service有哪些派生类-这些派生类的使用场景是什么-">7. Service有哪些派生类？这些派生类的使用场景是什么？</h3>
<p>这个问题不知道问的具体是什么，如果是要 <code>IntentService</code>那么可以参考官方文档的解释与使用说明：
<strong>扩展 IntentService 类</strong>
由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。</p>
<p>IntentService 执行以下操作：</p>
<pre><code>
创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。
创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。
在处理完所有启动请求后停止服务，因此您永远不必调用 stopSelf()。
提供 onBind() 的默认实现（返回 null）。
提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。
综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。（不过，您还需要为服务提供小型构造函数。）
</code></pre>
<p>以下是 IntentService 的实现示例：</p>
<pre><code>
public class HelloIntentService extends IntentService {

  /**
   * A constructor is required, and must call the super IntentService(String)
   * constructor with a name for the worker thread.
   */
  public HelloIntentService() {
      super(&quot;HelloIntentService&quot;);
  }

  /**
   * The IntentService calls this method from the default worker thread with
   * the intent that started the service. When this method returns, IntentService
   * stops the service, as appropriate.
   */
  @Override
  protected void onHandleIntent(Intent intent) {
      // Normally we would do some work here, like download a file.
      // For our sample, we just sleep for 5 seconds.
      try {
          Thread.sleep(5000);
      } catch (InterruptedException e) {
          // Restore interrupt status.
          Thread.currentThread().interrupt();
      }
  }
}
</code></pre>
<p>您只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>
<p>如果您决定还重写其他回调方法（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现，以便 IntentService 能够妥善处理工作线程的生命周期。</p>
<p>例如，onStartCommand() 必须返回默认实现（即，如何将 Intent 传递给 onHandleIntent()）：</p>
<pre><code>
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();
    return super.onStartCommand(intent,flags,startId);
}
</code></pre>
<p>除 onHandleIntent() 之外，您无需从中调用超类的唯一方法就是 onBind()（仅当服务允许绑定时，才需要实现该方法）。</p>
<h3 id="8-service与其它组件之间的通信实现方式有哪些-">8. Service与其它组件之间的通信实现方式有哪些？</h3>
<ol>
<li>binder</li>
<li>broadcast</li>
<li>其他参见线程和进程的通信方式</li>
</ol>
<h3 id="9-view的post-runnable-r-方法里-r会带来一个新的线程吗-多线程相关-">9. View的post(Runnable r)方法里，r会带来一个新的线程吗？多线程相关。</h3>
<p>不会，最终还是<code>handler</code>发送消息，执行在<code>UI</code>线程。
如下是源码和注释：</p>
<pre><code>
    /**
     * &lt;p&gt;Causes the Runnable to be added to the message queue.
     * The runnable will be run on the user interface thread.&lt;/p&gt;
     *
     * @param action The Runnable that will be executed.
     *
     * @return Returns true if the Runnable was successfully placed in to the
     *         message queue.  Returns false on failure, usually because the
     *         looper processing the message queue is exiting.
     *
     * @see #postDelayed
     * @see #removeCallbacks
     */
    public boolean post(Runnable action) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            return attachInfo.mHandler.post(action);
        }

        // Postpone the runnable until we know on which thread it needs to run.
        // Assume that the runnable will be successfully placed after attach.
        getRunQueue().post(action);
        return true;
    }
</code></pre>
<h3 id="10-在非ui线程中使用handler需要注意哪些问题-">10. 在非UI线程中使用Handler需要注意哪些问题？</h3>
<pre><code>
new Thread(){
        public void run(){
          Looper.prepare();//给当前线程初始化Looper
          Toast.makeText(getApplicationContext(),&quot;更新UI&quot;,0).show();//Toast初始化的时候会new Handler();无参构造默认获取当前线程的Looper，如果没有prepare过，则抛出题主描述的异常。上一句代码初始化过了，就不会出错。
          Looper.loop();//这句执行，Toast排队show所依赖的Handler发出的消息就有人处理了，Toast就可以吐出来了。但是，这个Thread也阻塞这里了，因为loop()是个for (;;) ...
        }
  }.start();
</code></pre>
<p>参考：
<a href="https://www.zhihu.com/question/51099935">https://www.zhihu.com/question/51099935</a>
<a href="https://www.zhihu.com/question/34652589">https://www.zhihu.com/question/34652589</a></p>
<h3 id="11-自定义view时有哪些重要的方法-它们的作用及执行顺序是怎样的-">11. 自定义View时有哪些重要的方法，它们的作用及执行顺序是怎样的？</h3>
<p>按照顺序：<code>onMeasure()</code> --&gt; <code>onLayout()</code> --&gt; <code>onDraw()</code>.其他的自己扩展吧。</p>
<h3 id="12-如何单独对listview上的一个item进行更新-">12. 如何单独对ListView上的一个item进行更新？</h3>
<ol>
<li>更新对应view的内容</li>
<li>通过ViewHolder去设置值</li>
<li>调用一次getView()方法（Google IO 推荐）</li>
</ol>
<p><a href="http://blog.csdn.net/linglongxin24/article/details/53020164">参考文章 http://blog.csdn.net/linglongxin24/article/details/53020164</a></p>
<h3 id="13-简析一下大图片的加载处理-">13. 简析一下大图片的加载处理。</h3>
<p>对Bitmap的理解，然后就是压缩图片。</p>
<h3 id="14-设计师只给了一套1280-800的ui图标注-如何进行其它分辨率尺寸屏幕的适配-">14. 设计师只给了一套1280*800的UI图标注，如何进行其它分辨率尺寸屏幕的适配？</h3>
<table>
<thead>
<tr>
<th style="text-align: center">名称</th>
<th style="text-align: center">像素密度范围</th>
<th style="text-align: center">图片大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">mdpi</td>
<td style="text-align: center">120dp~160dp</td>
<td style="text-align: center">48×48px</td>
</tr>
<tr>
<td style="text-align: center">hdpi</td>
<td style="text-align: center">160dp~240dp</td>
<td style="text-align: center">72×72px</td>
</tr>
<tr>
<td style="text-align: center">xhdpi</td>
<td style="text-align: center">240dp~320dp</td>
<td style="text-align: center">96×96px</td>
</tr>
<tr>
<td style="text-align: center">xxhdpi</td>
<td style="text-align: center">320dp~480dp</td>
<td style="text-align: center">144×144px</td>
</tr>
<tr>
<td style="text-align: center">xxxhdpi</td>
<td style="text-align: center">480dp~640dp</td>
<td style="text-align: center">192×192px</td>
</tr>
</tbody>
</table>
<p>以 720*1080 5英寸为例：
(720^2 + 1080^2)开方=260
放在xhdpi中。</p>
<p>本题中同理可以算得 293，还是xhdpi中。</p>
<h3 id="15-6-0系统新权限机制的解决方案-">15. 6.0系统新权限机制的解决方案。</h3>
<p>这个。。。没什么好说的，真正了解的很好说，不了解的话就有点绕。</p>
<h3 id="-你们精通的开源框架-问题来了">？ 你们精通的开源框架，问题来了</h3>
<p>写各种精通其实是可以的，要么真牛x，如果不是很牛x那就在最后加上一条精通----<strong>精通各种被打脸</strong>。</p>
<h3 id="16-eventbus的机制是什么-和handler的区别怎样-">16. EventBus的机制是什么？和Handler的区别怎样？</h3>
<p><code>EventBus</code>是采用观察者模式实现的事件订阅总线，可以用在应用程序中，组件之间，线程之间的通信，并且由于事件可以是任意类型的对象，所以使用起来更加的方便快捷。
<code>Handler</code>是 Android 的消息机制，集中解决线程间通信问题。</p>
<h3 id="17-rxjava的机制是什么-">17. RxJava的机制是什么？</h3>
<p>RxJava是使用Java语言，以<strong>响应式编程思维</strong>来进行编程的Java类库。参考<code>ReactiveX</code>。</p>
<h3 id="18-butterknife的机制是什么-">18. Butterknife的机制是什么？</h3>
<p>Java Annotation Processing技术，在Java代码编译成Java字节码的时候就已经处理了@Bind、@OnClick（ButterKnife还支持很多其他的注解）这些注解了。</p>
<blockquote>
<p><strong>Annotation processing 是javac中用于编译时扫描和解析Java注解的工具</strong>
Annotation processing是在编译阶段执行的，它的原理就是读入Java源代码，解析注解，然后生成新的Java代码。新生成的Java代码最后被编译成Java字节码，注解解析器（Annotation Processor）不能改变读入的Java 类，比如不能加入或删除Java方法。
参考：<a href="http://bxbxbai.github.io/2016/03/12/how-butterknife-works/">ButterKnife框架原理</a></p>
</blockquote>
<h3 id="19-okhttp是基于http连接还是socket连接-">19. Okhttp是基于HTTP连接还是Socket连接？</h3>
<p>基于<code>Http</code>的。</p>
<h3 id="20-例举一种orm框架-说说它的优缺点-">20. 例举一种ORM框架，说说它的优缺点。</h3>
<p>我熟悉的两种<code>GreenDao3</code>和<code>AndroidActive</code>，GreenDao 比较常规，注解不多（我这里都是指3.0版本后，之前的版本在生存实体的时候略显麻烦。），AndroidActive 相对而言注解较多，最后的综合性能上 GreenDao 排第一毫无争议。硬要说缺点的话就是 GreenDao 体积稍大。</p>
</div></body>
</html>